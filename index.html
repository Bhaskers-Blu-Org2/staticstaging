<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Happy Graphics Coding with Static Staging</title>
  <link rel="stylesheet" href="dingus/codemirror.css">
  <link rel="stylesheet" href="main.css">
</head>
<body>

<header>
<h1>Happy Graphics Coding with Static Staging</h1>
<section>
<p>Graphics programming should be fun. But today, you have to choose between pre-packaged engines like Unity and low-level, nitty-gritty APIs like OpenGL and Direct3D. If you want to control the GPU directly with shaders, you’re in for a steep learning curve.</p>
<p><em>Static staging</em> is a new programming language concept from <a href="http://research.microsoft.com">Microsoft Research</a> that makes it easy to program across the CPU–GPU boundary. The <a href="https://github.com/Microsoft/staticstaging">Static Staging Compiler</a> is an open-source prototype compiler that generates <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API">WebGL</a> and <a href="https://www.opengl.org/documentation/glsl/">GLSL</a> code from a single program with <em>staging annotations</em>.</p>
</section>
</header>

<main>
<p>This tutorial will show you how to write some simple graphics programs using the <a href="https://github.com/Microsoft/staticstaging">Static Staging Compiler</a>. Try editing any of the examples to see the result immediately. You can also check out <a href="https://github.com/Microsoft/staticstaging">the code on GitHub</a> or read the more technical <a href="http://microsoft.github.io/staticstaging/docs/">language manual</a> for details.</p>
<h2 id="lets-draw-something">Let’s Draw Something</h2>
<p>Here’s a tiny SSC program that draws a <a href="http://graphics.stanford.edu/data/3Dscanrep/">bunny</a>:</p>
<pre><code># Position the model.
var model = mat4.create();
mat4.scale(model, model, vec3(2.0, 2.0, 2.0));
mat4.translate(model, model, vec3(0.0, -5.0, 0.0));

# Load buffers and parameters for the model.
var mesh = bunny;
var position = mesh_positions(mesh);
var normal = mesh_normals(mesh);
var indices = mesh_indices(mesh);
var size = mesh_size(mesh);

# ---

render js&lt;
 vertex glsl&lt;
  gl_Position = projection * view * model * vec4(position, 1.0);
  fragment glsl&lt;
   gl_FragColor = vec4(abs(normal), 1.0);
  &gt;
 &gt;;
 draw_mesh(indices, size);
&gt;</code></pre>
<p>In modern graphics programming, <a href="https://en.wikipedia.org/wiki/Shader"><em>shader programs</em></a> are little chunks of code that run on the GPU to define objects’ appearance. Traditionally, you write shaders in special programming languages and then use OpenGL or Direct3D APIs to communicate with them from your CPU-side code.</p>
<p>With static staging, CPU and GPU code co-exist in the same program. Those angle brackets in the SSC example above, like <code>&lt; this &gt;</code>, delimit the boundaries between different kinds of code, called *stages. This example uses four stages:</p>
<ul>
<li>The <em>setup stage</em>, which appears outside of any angle brackets and runs once when the program starts up.</li>
<li>The <em>render stage</em>, which runs on the CPU to draw every frame.</li>
<li>The <em>vertex stage</em>, which corresponds to the <a href="https://www.opengl.org/wiki/Vertex_Shader">vertex shader</a> in WebGL: it runs code on the GPU for every vertex in an object to determine its position.</li>
<li>The <em>fragment stage</em>, which abstracts the <a href="https://www.opengl.org/wiki/Fragment_Shader">pixel shader</a> and determines the color of every pixel on the surface of an object.</li>
</ul>
<p>Those <code>render</code>, <code>vertex</code>, and <code>fragment</code> intrinsics decide when and where code runs. You can annotate each stage with its kind: the GPU-side stages get the <code>glsl</code> annotation and the render stage gets a <code>js</code> annotation so it gets compiled to plain JavaScript.</p>
<h2 id="another-example">Another Example</h2>
<p>We can use as many examples as we want!</p>
<pre><code>var model = mat4.create();

# Load buffers and parameters for the model.
var mesh = bunny;
var position = mesh_positions(mesh);
var normal = mesh_normals(mesh);
var indices = mesh_indices(mesh);
var size = mesh_size(mesh);

# ---

render js&lt;
 vertex glsl&lt;
  gl_Position = projection * view *
   vec4(position, 1.0);
  fragment glsl&lt;
   gl_FragColor =
    vec4(0.3, 0.1, 0.9, 1.0);
  &gt;
 &gt;;
 draw_mesh(indices, size);
&gt;</code></pre>
</main>

<template id="template-dingus">
<div class="sscdingus">
  <div class="input">
      <textarea class="code"></textarea>
  </div>

  <div class="output">
      <div class="error"></div>
      <div class="primary">
        <pre class="result"></pre>
        <div class="visual"></div>
      </div>
  </div>
</div>
</template>

<a class="github-fork-ribbon"
    href="https://github.com/Microsoft/staticstaging"
    title="Fork me on GitHub">Fork me on GitHub</a>

<script type="text/javascript" src="dingus/ssc.bundle.js"></script>
<script type="text/javascript" src="main.js"></script>

</body>
</html>
